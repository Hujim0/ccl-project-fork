#pragma once

#include <ccl/handler/cmd_handler.hpp>
#include <ccl/lex/lexical_analyzer.hpp>

enum CLexerToken: size_t {
    DECLS = 327680,
    KEYWORD = 196608,
    NONE = 0,
    OPERATORS = 131072,
    SEPARATOR = 65536,
    TYPE = 262144,
    EOI = 0,
    BAD_TOKEN = 1,
    COMMENT = 2,
    CURLY_OPENING = 65536,
    CURLY_CLOSING = 65537,
    LEFT_PARENTHESIS = 65538,
    RIGHT_PARENTHESIS = 65539,
    ANGLE_OPENING = 65540,
    ANGLE_CLOSING = 65541,
    COMMA = 65542,
    COLUMN = 65543,
    PREPROCESSOR = 65544,
    QUESTION_MARK = 65545,
    ADD = 131072,
    SUB = 131073,
    MUL = 131074,
    DIV = 131075,
    MOD = 131076,
    ASSIGN = 131077,
    ADD_ASSIGN = 131078,
    SUB_ASSIGN = 131079,
    MUL_ASSIGN = 131080,
    DIB_ASSIGN = 131081,
    MOD_ASSIGN = 131082,
    OR = 131083,
    AND = 131084,
    XOR = 131085,
    BITWISE_NOT = 131086,
    OR_ASSIGN = 131087,
    AND_ASSIGN = 131088,
    XOR_ASSIGN = 131089,
    LESS = 131090,
    GREATER = 131091,
    EQUAL = 131092,
    NOT_EQUAL = 131093,
    LESS_EQUAL = 131094,
    GREATER_EQUAL = 131095,
    LOGICAL_OR = 131096,
    LOGICAL_AND = 131097,
    LOGICAL_NOT = 131098,
    FOR = 196608,
    WHILE = 196609,
    SWITCH = 196610,
    CASE = 196611,
    RETURN = 196612,
    STRUCT = 196613,
    INT_T = 262144,
    CHAR_T = 262145,
    LONG_T = 262146,
    SHORT_T = 262147,
    FLOAT_T = 262148,
    DOUBLE_T = 262149,
    SIGNED_T = 262150,
    UNSIGNED_T = 262151,
    NUMBER = 327680,
    FLOAT = 327681,
    IDENTIFIER = 327682,
    CHAR = 327683,
    STRING = 327684,
};

// NOLINTNEXTLINE
static inline ccl::lex::LexicalAnalyzer CLexer(
    ccl::handler::Cmd::instance(),
    {
        { CLexerToken::COMMENT, R"( ! "//"[\n]*^ )" },
        { CLexerToken::COMMENT, R"( ! "/*" "*/"^* "*/" )" },
        { CLexerToken::CURLY_OPENING, R"( ! "{" )" },
        { CLexerToken::CURLY_CLOSING, R"( ! "}" )" },
        { CLexerToken::LEFT_PARENTHESIS, R"( ! "(" )" },
        { CLexerToken::RIGHT_PARENTHESIS, R"( ! [)] )" },
        { CLexerToken::ANGLE_OPENING, R"( ! "[" )" },
        { CLexerToken::ANGLE_CLOSING, R"( ! "]" )" },
        { CLexerToken::COMMA, R"( ! "," )" },
        { CLexerToken::COLUMN, R"( ! ";" )" },
        { CLexerToken::PREPROCESSOR, R"( ! "#" )" },
        { CLexerToken::QUESTION_MARK, R"( ! "?" )" },
        { CLexerToken::ADD, R"( ! "+" )" },
        { CLexerToken::SUB, R"( ! "-" )" },
        { CLexerToken::MUL, R"( ! "*" )" },
        { CLexerToken::DIV, R"( ! "/" )" },
        { CLexerToken::MOD, R"( ! "%" )" },
        { CLexerToken::ASSIGN, R"( ! "=" )" },
        { CLexerToken::ADD_ASSIGN, R"( ! "+=" )" },
        { CLexerToken::SUB_ASSIGN, R"( ! "-=" )" },
        { CLexerToken::MUL_ASSIGN, R"( ! "*=" )" },
        { CLexerToken::DIB_ASSIGN, R"( ! "/=" )" },
        { CLexerToken::MOD_ASSIGN, R"( ! "%=" )" },
        { CLexerToken::OR, R"( ! "|" )" },
        { CLexerToken::AND, R"( ! "&" )" },
        { CLexerToken::XOR, R"( ! "^" )" },
        { CLexerToken::BITWISE_NOT, R"( ! "~" )" },
        { CLexerToken::OR_ASSIGN, R"( ! "|=" )" },
        { CLexerToken::AND_ASSIGN, R"( ! "&=" )" },
        { CLexerToken::XOR_ASSIGN, R"( ! "^=" )" },
        { CLexerToken::LESS, R"( ! "<" )" },
        { CLexerToken::GREATER, R"( ! ">" )" },
        { CLexerToken::EQUAL, R"( ! "==" )" },
        { CLexerToken::NOT_EQUAL, R"( ! "!=" )" },
        { CLexerToken::LESS_EQUAL, R"( ! "<=" )" },
        { CLexerToken::GREATER_EQUAL, R"( ! ">=" )" },
        { CLexerToken::LOGICAL_OR, R"( ! "||" )" },
        { CLexerToken::LOGICAL_AND, R"( ! "&&" )" },
        { CLexerToken::LOGICAL_NOT, R"( ! "!" )" },
        { CLexerToken::FOR, R"( "for" )" },
        { CLexerToken::WHILE, R"( "while" )" },
        { CLexerToken::SWITCH, R"( "switch" )" },
        { CLexerToken::CASE, R"( "case" )" },
        { CLexerToken::RETURN, R"( "return" )" },
        { CLexerToken::STRUCT, R"( "struct" )" },
        { CLexerToken::INT_T, R"( "int" )" },
        { CLexerToken::CHAR_T, R"( "char" )" },
        { CLexerToken::LONG_T, R"( "long" )" },
        { CLexerToken::SHORT_T, R"( "short" )" },
        { CLexerToken::FLOAT_T, R"( "float" )" },
        { CLexerToken::DOUBLE_T, R"( "double" )" },
        { CLexerToken::SIGNED_T, R"( "signed" )" },
        { CLexerToken::UNSIGNED_T, R"( "unsigned" )" },
        { CLexerToken::NUMBER, R"( [0-9]+ ( [a-zA-Z_]+ [a-zA-Z0-9_]* )?p )" },
        { CLexerToken::FLOAT, R"( [0-9]+"."[0-9]* ( [a-zA-Z_]+ [a-zA-Z0-9_]* )?p )" },
        { CLexerToken::IDENTIFIER, R"( [a-zA-Z_]+[a-zA-Z0-9_]* )" },
        { CLexerToken::CHAR, R"( ! "\'" ([']^ | "\\\'" ) "\'" )" },
        { CLexerToken::STRING, R"( ! "\"" (["]^ | "\\\"")* "\"" )" },
    });

static inline const std::unordered_map<ccl::Id, ccl::string_view> ToStringCLexerToken
    {
    { CLexerToken::EOI, "EOI" },
    { CLexerToken::BAD_TOKEN, "BAD_TOKEN" },
    { CLexerToken::COMMENT, "COMMENT" },
    { CLexerToken::CURLY_OPENING, "CURLY_OPENING" },
    { CLexerToken::CURLY_CLOSING, "CURLY_CLOSING" },
    { CLexerToken::LEFT_PARENTHESIS, "LEFT_PARENTHESIS" },
    { CLexerToken::RIGHT_PARENTHESIS, "RIGHT_PARENTHESIS" },
    { CLexerToken::ANGLE_OPENING, "ANGLE_OPENING" },
    { CLexerToken::ANGLE_CLOSING, "ANGLE_CLOSING" },
    { CLexerToken::COMMA, "COMMA" },
    { CLexerToken::COLUMN, "COLUMN" },
    { CLexerToken::PREPROCESSOR, "PREPROCESSOR" },
    { CLexerToken::QUESTION_MARK, "QUESTION_MARK" },
    { CLexerToken::ADD, "ADD" },
    { CLexerToken::SUB, "SUB" },
    { CLexerToken::MUL, "MUL" },
    { CLexerToken::DIV, "DIV" },
    { CLexerToken::MOD, "MOD" },
    { CLexerToken::ASSIGN, "ASSIGN" },
    { CLexerToken::ADD_ASSIGN, "ADD_ASSIGN" },
    { CLexerToken::SUB_ASSIGN, "SUB_ASSIGN" },
    { CLexerToken::MUL_ASSIGN, "MUL_ASSIGN" },
    { CLexerToken::DIB_ASSIGN, "DIB_ASSIGN" },
    { CLexerToken::MOD_ASSIGN, "MOD_ASSIGN" },
    { CLexerToken::OR, "OR" },
    { CLexerToken::AND, "AND" },
    { CLexerToken::XOR, "XOR" },
    { CLexerToken::BITWISE_NOT, "BITWISE_NOT" },
    { CLexerToken::OR_ASSIGN, "OR_ASSIGN" },
    { CLexerToken::AND_ASSIGN, "AND_ASSIGN" },
    { CLexerToken::XOR_ASSIGN, "XOR_ASSIGN" },
    { CLexerToken::LESS, "LESS" },
    { CLexerToken::GREATER, "GREATER" },
    { CLexerToken::EQUAL, "EQUAL" },
    { CLexerToken::NOT_EQUAL, "NOT_EQUAL" },
    { CLexerToken::LESS_EQUAL, "LESS_EQUAL" },
    { CLexerToken::GREATER_EQUAL, "GREATER_EQUAL" },
    { CLexerToken::LOGICAL_OR, "LOGICAL_OR" },
    { CLexerToken::LOGICAL_AND, "LOGICAL_AND" },
    { CLexerToken::LOGICAL_NOT, "LOGICAL_NOT" },
    { CLexerToken::FOR, "FOR" },
    { CLexerToken::WHILE, "WHILE" },
    { CLexerToken::SWITCH, "SWITCH" },
    { CLexerToken::CASE, "CASE" },
    { CLexerToken::RETURN, "RETURN" },
    { CLexerToken::STRUCT, "STRUCT" },
    { CLexerToken::INT_T, "INT_T" },
    { CLexerToken::CHAR_T, "CHAR_T" },
    { CLexerToken::LONG_T, "LONG_T" },
    { CLexerToken::SHORT_T, "SHORT_T" },
    { CLexerToken::FLOAT_T, "FLOAT_T" },
    { CLexerToken::DOUBLE_T, "DOUBLE_T" },
    { CLexerToken::SIGNED_T, "SIGNED_T" },
    { CLexerToken::UNSIGNED_T, "UNSIGNED_T" },
    { CLexerToken::NUMBER, "NUMBER" },
    { CLexerToken::FLOAT, "FLOAT" },
    { CLexerToken::IDENTIFIER, "IDENTIFIER" },
    { CLexerToken::CHAR, "CHAR" },
    { CLexerToken::STRING, "STRING" },
};
